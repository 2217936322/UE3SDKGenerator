#pragma once
#include <string>

/*
# ========================================================================================= #
# Pieces Of Code																			#
# ========================================================================================= #
*/

std::string TArray_Iterator =
"template<typename TArray>\n"
"struct TIterator\n"
"{\n"
"public:\n"
"\tusing ElementType = typename TArray::ElementType;\n"
"\tusing ElementPointer = ElementType*;\n"
"\tusing ElementReference = ElementType&;\n"
"\tusing ElementConstReference = const ElementType&;\n"
"\n"
"private:\n"
"\tElementPointer IteratorData;\n"
"\n"
"public:\n"
"\tTIterator(ElementPointer inElementPointer)\n"
"\t{\n"
"\t\tIteratorData = inElementPointer;\n"
"\t}\n"
"\n"
"public:\n"
"\tTIterator& operator++()\n"
"\t{\n"
"\t\tIteratorData++;\n"
"\t\treturn *this;\n"
"\t}\n"
"\n"
"\tTIterator operator++(int)\n"
"\t{\n"
"\t\tTIterator iteratorCopy = *this;\n"
"\t\t++(*this);\n"
"\t\treturn iteratorCopy;\n"
"\t}\n"
"\n"
"\tTIterator& operator--()\n"
"\t{\n"
"\t\tIteratorData--;\n"
"\t\treturn *this;\n"
"\t}\n"
"\n"
"\tTIterator operator--(int)\n"
"\t{\n"
"\t\tTIterator iteratorCopy = *this;\n"
"\t\t--(*this);\n"
"\t\treturn iteratorCopy;\n"
"\t}\n"
"\n"
"\tElementReference operator[](int32_t index)\n"
"\t{\n"
"\t\treturn *(IteratorData[index]);\n"
"\t}\n"
"\n"
"\tElementPointer operator->()\n"
"\t{\n"
"\t\treturn IteratorData;\n"
"\t}\n"
"\n"
"\tElementReference operator*()\n"
"\t{\n"
"\t\treturn *IteratorData;\n"
"\t}\n"
"\n"
"\tbool operator==(const TIterator& other) const\n"
"\t{\n"
"\t\treturn (IteratorData == other.IteratorData);\n"
"\t}\n"
"\n"
"\tbool operator!=(const TIterator& other) const\n"
"\t{\n"
"\t\treturn !(*this == other);\n"
"\t}\n"
"};\n\n";

std::string TArray_Struct =
"template<typename InElementType>\n"
"struct TArray\n"
"{\n"
"public:\n"
"\tusing ElementType = InElementType;\n"
"\tusing ElementPointer = ElementType*;\n"
"\tusing ElementReference = ElementType&;\n"
"\tusing ElementConstReference = const ElementType&;\n"
"\tusing Iterator = TIterator<TArray<ElementType>>;\n"
"\n"
"private:\n"
"\tElementPointer ArrayData;\n"
"\tint32_t ArrayCount;\n"
"\tint32_t ArrayMax;\n"
"\n"
"public:\n"
"\tTArray()\n"
"\t{\n"
"\t\tArrayData = nullptr;\n"
"\t\tArrayCount = 0;\n"
"\t\tArrayMax = 0;\n"
"\n"
"\t\t//ReAllocate(sizeof(ElementType));\n"
"\t}\n"
"\n"
"\t~TArray()\n"
"\t{\n"
"\t\t//Clear();\n"
"\t\t//::operator delete(ArrayData, ArrayMax * sizeof(ElementType));\n"
"\t}\n"
"\n"
"public:\n"
"\tElementConstReference operator[](int32_t index) const\n"
"\t{\n"
"\t\tif (index <= ArrayCount)\n"
"\t\t{\n"
"\t\t\treturn ArrayData[index];\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tElementReference operator[](int32_t index)\n"
"\t{\n"
"\t\tif (index <= ArrayCount)\n"
"\t\t{\n"
"\t\t\treturn ArrayData[index];\n"
"\t\t} \n"
"\t}\n"
"\n"
"\tElementConstReference At(const int32_t index) const\n"
"\t{\n"
"\t\tif (index <= ArrayCount)\n"
"\t\t{\n"
"\t\t\treturn ArrayData[index];\n"
"\t\t} \n"
"\t}\n"
"\n"
"\tElementReference At(const int32_t index)\n"
"\t{\n"
"\t\tif (index <= ArrayCount)\n"
"\t\t{\n"
"\t\t\treturn ArrayData[index];\n"
"\t\t} \n"
"\t}\n"
"\n"
"\tvoid Add(ElementConstReference newElement)\n"
"\t{\n"
"\t\tif (ArrayCount >= ArrayMax)\n"
"\t\t{\n"
"\t\t\tReAllocate(sizeof(ElementType) * (ArrayCount + 1));\n"
"\t\t}\n"
"\n"
"\t\tnew(&ArrayData[ArrayCount]) ElementType(newElement);\n"
"\t\tArrayCount++;\n"
"\t}\n"
"\n"
"\tvoid Add(ElementReference& newElement)\n"
"\t{\n"
"\t\tif (ArrayCount >= ArrayMax)\n"
"\t\t{\n"
"\t\t\tReAllocate(sizeof(ElementType) * (ArrayCount + 1));\n"
"\t\t}\n"
"\n"
"\t\tnew(&ArrayData[ArrayCount]) ElementType(newElement);\n"
"\t\tArrayCount++;\n"
"\t}\n"
"\n"
"\tvoid PopBack()\n"
"\t{\n"
"\t\tif (ArrayCount > 0)\n"
"\t\t{\n"
"\t\t\tArrayCount--;\n"
"\t\t\tArrayData[ArrayCount].~ElementType();\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tvoid Clear()\n"
"\t{\n"
"\t\tfor (int32_t i = 0; i < ArrayCount; i++)\n"
"\t\t{\n"
"\t\t\tArrayData[i].~ElementType();\n"
"\t\t}\n"
"\n"
"\t\tArrayCount = 0;\n"
"\t}\n"
"\n"
"\tint32_t Num() const\n"
"\t{\n"
"\t\treturn ArrayCount;\n"
"\t}\n"
"\n"
"\tint32_t Max() const\n"
"\t{\n"
"\t\treturn ArrayMax;\n"
"\t}\n"
"\n"
"\tIterator begin()\n"
"\t{\n"
"\t\treturn Iterator(ArrayData);\n"
"\t}\n"
"\n"
"\tIterator end()\n"
"\t{\n"
"\t\treturn Iterator(ArrayData + ArrayCount);\n"
"\t}\n"
"\n"
"private:\n"
"\tvoid ReAllocate(int32_t newArrayMax)\n"
"\t{\n"
"\t\tElementPointer newArrayData = (ElementPointer)::operator new(newArrayMax * sizeof(ElementType));\n"
"\n"
"\t\tint32_t newNum = ArrayCount;\n"
"\n"
"\t\tif (newArrayMax < newNum)\n"
"\t\t{\n"
"\t\t\tnewNum = newArrayMax;\n"
"\t\t}\n"
"\n"
"\t\tfor (int32_t i = 0; i < newNum; i++)\n"
"\t\t{\n"
"\t\t\tnew(newArrayData + i) ElementType(std::move(ArrayData[i]));\n"
"\t\t}\n"
"\n"
"\t\tfor (int32_t i = 0; i < ArrayCount; i++)\n"
"\t\t{\n"
"\t\t\tArrayData[i].~ElementType();\n"
"\t\t}\n"
"\n"
"\t\t::operator delete(ArrayData, ArrayMax * sizeof(ElementType));\n"
"\t\tArrayData = newArrayData;\n"
"\t\tArrayMax = newArrayMax;\n"
"\t}\n"
"};\n";

std::string FNameEntry_Struct =
"struct FNameEntry\n"
"{\n"
"\tunsigned char\tUnknownData00[0x18];\n"
"\twchar_t\t\t\tName[0x100];\n"
"};\n";

std::string FName_Struct =
"struct FName\n"
"{\n"
"public:\n"
"\tusing ElementType = const wchar_t;\n"
"\tusing ElementPointer = ElementType*;\n"
"\n"
"private:\n"
"\tint32_t\tFNameEntryId;\n"
"\tint32_t\tInstanceNumber;\n"
"\n"
"public:\n"
"\tFName()\n"
"\t{\n"
"\t\tFNameEntryId = 0;\n"
"\t\tInstanceNumber = 0;\n"
"\t}\n"
"\n"
"\tFName(int i)\n"
"\t{\n"
"\t\tFNameEntryId = i;\n"
"\t\tInstanceNumber = 0;\n"
"\t}\n"
"\n"
"\tFName(ElementPointer findName)\n"
"\t{\n"
"\t\tstatic TArray<int> nameCache;\n"
"\n"
"\t\tfor (int entry : nameCache)\n"
"\t\t{\n"
"\t\t\tif (Names()->At(entry))\n"
"\t\t\t{\n"
"\t\t\t\tif (!wcscmp(Names()->At(nameCache[entry])->Name, findName))\n"
"\t\t\t\t{\n"
"\t\t\t\t\tFNameEntryId = nameCache[entry];\n"
"\t\t\t\t\treturn;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tfor (int i = 0; i < Names()->Num(); i++)\n"
"\t\t{\n"
"\t\t\tif (Names()->At(i))\n"
"\t\t\t{\n"
"\t\t\t\tif (!wcscmp(Names()->At(i)->Name, findName))\n"
"\t\t\t\t{\n"
"\t\t\t\t\tnameCache.Add(i);\n"
"\t\t\t\t\tFNameEntryId = i;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\t~FName() {}\n"
"\n"
"public:\n"
"\tstatic TArray<FNameEntry*>* Names()\n"
"\t{\n"
"\t\tTArray<struct FNameEntry*>* GNamesArray = reinterpret_cast<TArray<struct FNameEntry*>*>(GNames);\n"
"\t\treturn GNamesArray;\n"
"\t}\n"
"\n"
"\tint32_t GetDisplayIndex() const\n"
"\t{\n"
"\t\treturn FNameEntryId;\n"
"\t}\n"
"\n"
"\tconst FNameEntry GetDisplayNameEntry() const\n"
"\t{\n"
"\t\tif (IsValid())\n"
"\t\t{\n"
"\t\t\treturn *Names()->At(FNameEntryId);\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tFNameEntry* GetEntry()\n"
"\t{\n"
"\t\tif (IsValid())\n"
"\t\t{\n"
"\t\t\treturn Names()->At(FNameEntryId);\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tint32_t GetNumber() const\n"
"\t{\n"
"\t\treturn InstanceNumber;\n"
"\t}\n"
"\n"
"\tvoid SetNumber(int32_t newNumber)\n"
"\t{\n"
"\t\tInstanceNumber = newNumber;\n"
"\t}\n"
"\n"
"\tstd::string ToString() const\n"
"\t{\n"
"\t\tif (IsValid())\n"
"\t\t{\n"
"\t\t\tstd::wstring ws(GetDisplayNameEntry().Name);\n"
"\t\t\tstd::string str(ws.begin(), ws.end());\n"
"\t\t\treturn str;\n"
"\t\t}\n"
"\n"
"\t\treturn std::string(\"UnknownName\");\n"
"\t}\n"
"\n"
"\tbool IsValid() const\n"
"\t{\n"
"\t\tif (FNameEntryId > Names()->Num() || !Names()->At(FNameEntryId))\n"
"\t\t{\n"
"\t\t\treturn false;\n"
"\t\t}\n"
"\n"
"\t\treturn true;\n"
"\t}\n"
"\n"
"\tFName operator=(const FName& other)\n"
"\t{\n"
"\t\tFNameEntryId = other.FNameEntryId;\n"
"\t\tInstanceNumber = other.InstanceNumber;\n"
"\t\treturn *this;\n"
"\t}\n"
"\n"
"\tbool operator==(const FName& name) const\n"
"\t{\n"
"\t\treturn (FNameEntryId == name.FNameEntryId);\n"
"\t}\n"
"};\n\n";

std::string FScriptDelegate_Struct =
"struct FScriptDelegate\n"
"{\n"
"\tunsigned char UnknownData00[0x18];\n"
"};\n";

std::string FPointer_Struct =
"struct FPointer\n"
"{\n"
"\tuintptr_t Dummy;\n"
"};\n";

std::string FQWord_Struct =
"struct FQWord\n"
"{\n"
"\tint A;\n"
"\tint B;\n"
"};\n";

std::string FString_Struct =
"struct FString\n"
"{\n"
"public:\n"
"\tusing ElementType = const wchar_t;\n"
"\tusing ElementPointer = ElementType*;\n"
"\n"
"private:\n"
"\tElementPointer ArrayData;\n"
"\tint32_t ArrayCount;\n"
"\tint32_t ArrayMax;\n"
"\n"
"public:\n"
"\tFString()\n"
"\t{\n"
"\t\tArrayData = nullptr;\n"
"\t\tArrayCount = 0;\n"
"\t\tArrayMax = 0;\n"
"\t}\n"
"\n"
"\tFString(ElementPointer other)\n"
"\t{\n"
"\t\tArrayData = nullptr;\n"
"\t\tArrayCount = 0;\n"
"\t\tArrayMax = 0;\n"
"\n"
"\t\tArrayMax = ArrayCount = *other ? (wcslen(other) + 1) : 0;\n"
"\n"
"\t\tif (ArrayCount > 0)\n"
"\t\t{\n"
"\t\t\tArrayData = other;\n"
"\t\t}\n"
"\t}\n"
"\n"
"\t~FString() {}\n"
"\n"
"public:\n"
"\tstd::string ToString() const\n"
"\t{\n"
"\t\tif (!IsValid())\n"
"\t\t{\n"
"\t\t\tstd::wstring wideStr(ArrayData);\n"
"\t\t\tstd::string str(wideStr.begin(), wideStr.end());\n"
"\t\t\treturn str;\n"
"\t\t}\n"
"\n"
"\t\treturn \"null\";\n"
"\t}\n"
"\n"
"\tbool IsValid() const\n"
"\t{\n"
"\t\treturn !ArrayData;\n"
"\t}\n"
"\n"
"\tFString operator=(ElementPointer other)\n"
"\t{\n"
"\t\tif (ArrayData != other)\n"
"\t\t{\n"
"\t\t\tArrayMax = ArrayCount = *other ? (wcslen(other) + 1) : 0;\n"
"\n"
"\t\t\tif (ArrayCount > 0)\n"
"\t\t\t{\n"
"\t\t\t\tArrayData = other;\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\treturn *this;\n"
"\t}\n"
"\n"
"\tbool operator==(const FString& other)\n"
"\t{\n"
"\t\treturn (!wcscmp(ArrayData, other.ArrayData));\n"
"\t}\n"
"};\n";

std::string UClass_Fields =
"\tclass UField*\tNext;\t// 0x0060 (0x08) NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned char\tUnknownData00[0x8];\t// 0x0068 (0x08) NOT AUTO-GENERATED PROPERTY\n";

std::string UStruct_Fields =
"\tunsigned char\tUnknownData00[0x10];\t// 0x0070 (0x10) NOT AUTO-GENERATED PROPERTY\n"
"\tclass UField*\tSuperField;\t// 0x0080 (0x08) NOT AUTO-GENERATED PROPERTY\n"
"\tclass UField*\tChildren;\t// 0x0088 (0x08) NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned long\tPropertySize;\t// 0x0090 (0x08) NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned char\tUnknownData01[0x98];\t// 0x0094 (0x9C) NOT AUTO-GENERATED PROPERTY\n";

std::string UFunction_Fields =
"\tunsigned long\tFunctionFlags;\t// NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned short\tiNative;\t// NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned short\tRepOffset;\t// NOT AUTO-GENERATED PROPERTY\n"
"\tstruct FName\tFriendlyName;\t// NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned short\tNumParms;\t// NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned short\tParmsSize;\t// NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned long\tReturnValueOffset;\t// NOT AUTO-GENERATED PROPERTY\n"
"\tunsigned char\tUnknownData00[0x8];\t// NOT AUTO-GENERATED PROPERTY\n"
"\tvoid*\t\t\tFunc;\t// NOT AUTO-GENERATED PROPERTY \n";

std::string UObject_FunctionDescriptions =
"\tstatic TArray<class UObject*>* GObjObjects();\n\n"

"\tchar const* GetName();\n"
"\tchar const* GetNameCPP();\n"
"\tchar const* GetFullName();\n"
"\t//char const* GetPackageName();\n"
"\tUObject* GetPackageObj();\n\n"

"\ttemplate<typename T> static T* FindObject(char const* objectFullName);\n"
"\ttemplate<typename T> static unsigned int CountObject(char const* objectName);\n"
"\tstatic UClass* FindClass(char const* classFullName);\n\n"

"\tbool IsA(UClass* pClass);\n"
"\tbool IsA(int objInternalInteger);\n\n";

std::string UObject_Functions =
"TArray<class UObject*>* UObject::GObjObjects()\n"
"{\n"
"\tTArray<class UObject*>* objectArray = reinterpret_cast<TArray<class UObject*>*>(GObjects);\n"
"\treturn objectArray;\n"
"}\n"
"\n"
"char const* UObject::GetName()\n"
"{\n"
"\tstatic char charBuffer[512];\n"
"\tmemset(charBuffer, 0, sizeof charBuffer);\n"
"\tstd::string name = this->Name.ToString();\n"
"\tsprintf_s(charBuffer, \"%s\", name.c_str());\n"
"\n"
"\treturn charBuffer;\n"
"}\n"
"\n"
"char const* UObject::GetNameCPP()\n"
"{\n"
"\tstatic char charBuffer[512];\n"
"\n"
"\tif (this->IsA(UClass::StaticClass()))\n"
"\t{\n"
"\t\tUClass* uClass = reinterpret_cast<UClass*>(this);\n"
"\n"
"\t\twhile (uClass)\n"
"\t\t{\n"
"\t\t\tstd::string className = uClass->GetName();\n"
"\n"
"\t\t\tif (className == \"Actor\")\n"
"\t\t\t{\n"
"\t\t\t\tstrcpy_s(charBuffer, \"A\");\n"
"\t\t\t\tbreak;\n"
"\t\t\t}\n"
"\t\t\telse if (className == \"Object\")\n"
"\t\t\t{\n"
"\t\t\t\tstrcpy_s(charBuffer, \"U\");\n"
"\t\t\t\tbreak;\n"
"\t\t\t}\n"
"\n"
"\t\t\tuClass = reinterpret_cast<UClass*>(uClass->SuperField);\n"
"\t\t}\n"
"\t}\n"
"\telse\n"
"\t{\n"
"\t\tstrcpy_s(charBuffer, \"F\");\n"
"\t}\n"
"\n"
"\tstrcat_s(charBuffer, this->GetName());\n"
"\n"
"\treturn charBuffer;\n"
"}\n"
"\n"
"char const* UObject::GetFullName()\n"
"{\n"
"\tif (this->Class && this->Outer)\n"
"\t{\n"
"\t\tstatic char charBuffer[1024];\n"
"\t\tchar tempBuffer[1024];\n"
"\t\tstrcpy_s(charBuffer, this->GetName());\n"
"\n"
"\t\tfor (UObject* uOuter = this->Outer; uOuter; uOuter = uOuter->Outer)\n"
"\t\t{\n"
"\t\t\tstrcpy_s(tempBuffer, uOuter->GetName());\n"
"\t\t\tstrcat_s(tempBuffer, \".\");\n"
"\n"
"\t\t\tsize_t len1 = strlen(tempBuffer);\n"
"\t\t\tsize_t len2 = strlen(charBuffer);\n"
"\n"
"\t\t\tmemmove(charBuffer + len1, charBuffer, len1 + len2 + 1);\n"
"\t\t\tmemcpy(charBuffer, tempBuffer, len1);\n"
"\t\t}\n"
"\n"
"\t\tstrcpy_s(tempBuffer, this->Class->GetName());\n"
"\t\tstrcat_s(tempBuffer, \" \");\n"
"\n"
"\t\tsize_t len1 = strlen(tempBuffer);\n"
"\t\tsize_t len2 = strlen(charBuffer);\n"
"\n"
"\t\tmemmove(charBuffer + len1, charBuffer, len1 + len2 + 1);\n"
"\t\tmemcpy(charBuffer, tempBuffer, len1);\n"
"\n"
"\t\treturn charBuffer;\n"
"\t}\n"
"\n"
"\treturn \"null\";\n"
"}\n"
"\n"
"UObject* UObject::GetPackageObj()\n"
"{\n"
"\tUObject* uPackage = nullptr;\n"
"\n"
"\tfor (UObject* uOuter = this->Outer; uOuter; uOuter = uOuter->Outer)\n"
"\t{\n"
"\t\tuPackage = uOuter;\n"
"\t}\n"
"\n"
"\treturn uPackage;\n"
"}\n"
"\n"
"template<typename T> T* UObject::FindObject(char const* objectFullName)\n"
"{\n"
"\tfor (UObject* uObject : *UObject::GObjObjects())\n"
"\t{\n"
"\t\tif (uObject && uObject->IsA(T::StaticClass()))\n"
"\t\t{\n"
"\t\t\tif (uObject->GetFullName() == objectFullName)\n"
"\t\t\t{\n"
"\t\t\t\treturn reinterpret_cast<T*>(uObject);\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn nullptr;\n"
"}\n"
"\n"
"template<typename T> static unsigned int UObject::CountObject(char const* objectName)\n"
"{\n"
"\tstatic std::map<std::string, int> countCache;\n"
"\n"
"\tif (countCache.find(objectName) == countCache.end())\n"
"\t{\n"
"\t\tcountCache[objectName] = 0;\n"
"\n"
"\t\tfor (UObject* uObject : *UObject::GObjObjects())\n"
"\t\t{\n"
"\t\t\tif (uObject && uObject->IsA(T::StaticClass()))\n"
"\t\t\t{\n"
"\t\t\t\tif (uObject->GetName() == objectName)\n"
"\t\t\t\t{\n"
"\t\t\t\t\tcountCache[std::string(uObject->GetName())]++;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn countCache[objectName];\n"
"}\n"
"\n"
"UClass* UObject::FindClass(char const* classFullName)\n"
"{\n"
"\tstatic bool initialized = false;\n"
"\tstatic std::map<std::string, UClass*> foundClasses{};\n"
"\n"
"\tif (!initialized)\n"
"\t{\n"
"\t\tfor (UObject* uObject : *UObject::GObjObjects())\n"
"\t\t{\n"
"\t\t\tif (uObject)\n"
"\t\t\t{\n"
"\t\t\t\tstd::string objectFullName = uObject->GetFullName();\n"
"\n"
"\t\t\t\tif (objectFullName.find(\"Class\") == 0)\n"
"\t\t\t\t{\n"
"\t\t\t\t\tfoundClasses[objectFullName] = reinterpret_cast<UClass*>(uObject);\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tinitialized = true;\n"
"\t}\n"
"\n"
"\tif (foundClasses.find(classFullName) != foundClasses.end())\n"
"\t{\n"
"\t\treturn foundClasses[classFullName];\n"
"\t}\n"
"\n"
"\treturn nullptr;\n"
"}\n"
"\n"
"bool UObject::IsA(UClass* uClass)\n"
"{\n"
"\tfor (UClass* uSuperClass = this->Class; uSuperClass; uSuperClass = reinterpret_cast<UClass*>(uSuperClass->SuperField))\n"
"\t{\n"
"\t\tif (uSuperClass == uClass)\n"
"\t\t{\n"
"\t\t\treturn true;\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn false;\n"
"}\n"
"\n"
"bool UObject::IsA(int objInternalInteger)\n"
"{\n"
"\tUClass* uClass = UObject::GObjObjects()->At(objInternalInteger)->Class;\n"
"\n"
"\tif (uClass)\n"
"\t{\n"
"\t\treturn this->IsA(uClass);\n"
"\t}\n"
"\n"
"\treturn false;\n"
"}\n\n";

std::string UFunction_Functions =
"UFunction* UFunction::FindFunction(char const* functionFullName)\n"
"{\n"
"\tstatic bool initialized = false;\n"
"\tstatic std::map<std::string, UFunction*> foundFunctions{};\n"
"\n"
"\tif (!initialized)\n"
"\t{\n"
"\t\tfor (UObject* uObject : *UObject::GObjObjects())\n"
"\t\t{\n"
"\t\t\tif (uObject)\n"
"\t\t\t{\n"
"\t\t\t\tstd::string objectFullName = uObject->GetFullName();\n"
"\n"
"\t\t\t\tif (objectFullName.find(\"Function\") == 0)\n"
"\t\t\t\t{\n"
"\t\t\t\t\tfoundFunctions[objectFullName] = reinterpret_cast<UFunction*>(uObject);\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tinitialized = true;\n"
"\t}\n"
"\n"
"\tif (foundFunctions.find(functionFullName) != foundFunctions.end())\n"
"\t{\n"
"\t\treturn foundFunctions[functionFullName];\n"
"\t}\n"
"\n"
"\treturn nullptr;\n"
"}\n\n";